//! Core types for patch operations

use serde::{Deserialize, Serialize};
use std::path::PathBuf;

/// A patch operation type
#[derive(Debug, Clone, Copy, PartialEq, Eq, Deserialize, Serialize)]
#[serde(rename_all = "snake_case")]
pub enum Operation {
    Replace,
    AppendEof,
    PrependBof,
    Overwrite,
}

/// Reindentation specification
#[derive(Debug, Clone, PartialEq, Eq, Deserialize, Serialize)]
pub struct Reindent {
    pub strip: Option<String>,
    pub add: Option<String>,
}

/// A single patch request
#[derive(Debug, Clone, Deserialize, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct PatchRequest {
    pub operation: Operation,
    pub old_text: Option<String>,
    pub new_text: Option<String>,
    pub to_clipboard: Option<String>,
    pub from_clipboard: Option<String>,
    pub reindent: Option<Reindent>,
}

/// Input for a patch operation
#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct PatchInput {
    pub path: String,
    pub patches: Vec<PatchRequest>,
}

/// A located edit in the content
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct EditSpec {
    pub offset: usize,
    pub length: usize,
}

/// An edit to apply
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Edit {
    pub offset: usize,
    pub length: usize,
    pub replacement: String,
}

/// Effects produced by patch planning
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum PatchEffect {
    /// Write content to a file (creates parent dirs as needed)
    WriteFile {
        path: PathBuf,
        content: String,
    },
}

/// Result of planning patches
#[derive(Debug, Clone)]
pub struct PatchPlan {
    /// The effects to execute
    pub effects: Vec<PatchEffect>,
    /// The resulting content after patches
    pub resulting_content: String,
    /// Generated diff for display
    pub diff: String,
    /// Warning if file appears auto-generated
    pub autogenerated_warning: bool,
}

/// Errors that can occur during patch planning
#[derive(Debug, Clone, PartialEq, Eq, thiserror::Error)]
pub enum PatchError {
    #[error("Cannot use replace operation on non-existent file")]
    ReplaceOnNonexistent,
    
    #[error("Replace operation requires oldText")]
    MissingOldText,
    
    #[error("Clipboard '{0}' not found")]
    ClipboardNotFound(String),
    
    #[error("oldText not found in file")]
    OldTextNotFound,
    
    #[error("oldText appears {0} times in file (must be unique)")]
    OldTextNotUnique(usize),
    
    #[error("Edit extends beyond file content")]
    EditOutOfBounds,
    
    #[error("Line does not start with expected prefix '{prefix}':\n{line}")]
    ReindentPrefixMismatch { prefix: String, line: String },
    
    #[error("No patches provided")]
    NoPatches,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_operation_deserialize() {
        let json = r#""replace""#;
        let op: Operation = serde_json::from_str(json).unwrap();
        assert_eq!(op, Operation::Replace);
    }

    #[test]
    fn test_patch_request_deserialize() {
        let json = r#"{
            "operation": "replace",
            "oldText": "hello",
            "newText": "world"
        }"#;
        let req: PatchRequest = serde_json::from_str(json).unwrap();
        assert_eq!(req.operation, Operation::Replace);
        assert_eq!(req.old_text, Some("hello".to_string()));
        assert_eq!(req.new_text, Some("world".to_string()));
    }
}
