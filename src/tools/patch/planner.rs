//! Pure patch planning logic
//!
//! The `PatchPlanner` contains all the core logic for patch operations,
//! operating on string content without any IO. This makes it ideal
//! for property-based testing.

use super::matching::find_unique_match;
use super::types::{Edit, Operation, PatchEffect, PatchError, PatchPlan, PatchRequest, Reindent};
use similar::TextDiff;
use std::collections::HashMap;
use std::path::Path;

/// Pure patch planner - no IO operations
///
/// Maintains clipboard state across calls and produces effects
/// that describe what IO operations should be performed.
#[derive(Debug, Clone, Default)]
pub struct PatchPlanner {
    clipboards: HashMap<String, String>,
}

impl PatchPlanner {
    pub fn new() -> Self {
        Self::default()
    }

    /// Create a planner with pre-populated clipboards (useful for testing)
    #[allow(dead_code)] // For testing
    pub fn with_clipboards(clipboards: HashMap<String, String>) -> Self {
        Self { clipboards }
    }

    /// Get current clipboard contents (for testing)
    #[allow(dead_code)] // For testing
    pub fn clipboards(&self) -> &HashMap<String, String> {
        &self.clipboards
    }

    /// Plan patches for a file
    ///
    /// # Arguments
    /// * `path` - The file path (used for effects and diff display)
    /// * `current_content` - Current file content, or None if file doesn't exist
    /// * `patches` - The patches to apply
    ///
    /// # Returns
    /// A `PatchPlan` containing effects to execute and metadata
    pub fn plan(
        &mut self,
        path: &Path,
        current_content: Option<&str>,
        patches: &[PatchRequest],
    ) -> Result<PatchPlan, PatchError> {
        if patches.is_empty() {
            return Err(PatchError::NoPatches);
        }

        // Validate operations on non-existent files
        let original = if let Some(content) = current_content {
            content.to_string()
        } else {
            for patch in patches {
                if matches!(patch.operation, Operation::Replace) {
                    return Err(PatchError::ReplaceOnNonexistent);
                }
            }
            String::new()
        };

        // Build edit list
        let edits = self.build_edits(&original, patches)?;

        // Apply edits to get result
        let resulting_content = Self::apply_edits(&original, edits)?;

        // Generate diff
        let diff = generate_diff(&path.display().to_string(), &original, &resulting_content);

        // Check for autogenerated markers
        let autogenerated_warning = is_autogenerated(&resulting_content);

        // Build effects
        let effects = vec![PatchEffect::WriteFile {
            path: path.to_path_buf(),
            content: resulting_content.clone(),
        }];

        Ok(PatchPlan {
            effects,
            resulting_content,
            diff,
            autogenerated_warning,
        })
    }

    /// Build a list of edits from patch requests
    fn build_edits(
        &mut self,
        original: &str,
        patches: &[PatchRequest],
    ) -> Result<Vec<Edit>, PatchError> {
        let mut edits = Vec::new();

        for patch in patches {
            // Get new text (from clipboard if specified)
            // Treat empty string as None (LLMs sometimes pass "" instead of omitting)
            let mut new_text = match &patch.from_clipboard {
                Some(name) if !name.is_empty() => self
                    .clipboards
                    .get(name)
                    .ok_or_else(|| PatchError::ClipboardNotFound(name.clone()))?
                    .clone(),
                _ => patch.new_text.clone().unwrap_or_default(),
            };

            // Apply reindentation
            if let Some(reindent) = &patch.reindent {
                new_text = apply_reindent(&new_text, reindent)?;
            }

            // Store to clipboard if requested (ignore empty string names)
            if let Some(name) = &patch.to_clipboard {
                if !name.is_empty() {
                    if let Some(old_text) = &patch.old_text {
                        self.clipboards.insert(name.clone(), old_text.clone());
                    }
                }
            }

            // Determine edit based on operation
            let edit = match patch.operation {
                Operation::PrependBof => Edit {
                    offset: 0,
                    length: 0,
                    replacement: new_text,
                },
                Operation::AppendEof => Edit {
                    offset: original.len(),
                    length: 0,
                    replacement: new_text,
                },
                Operation::Overwrite => Edit {
                    offset: 0,
                    length: original.len(),
                    replacement: new_text,
                },
                Operation::Replace => {
                    let old_text = patch.old_text.as_ref().ok_or(PatchError::MissingOldText)?;

                    let spec = find_unique_match(original, old_text)?;

                    // Update clipboard with actual matched text if it differed
                    if let Some(name) = &patch.to_clipboard {
                        if !name.is_empty() {
                            let matched = &original[spec.offset..spec.offset + spec.length];
                            self.clipboards.insert(name.clone(), matched.to_string());
                        }
                    }

                    Edit {
                        offset: spec.offset,
                        length: spec.length,
                        replacement: new_text,
                    }
                }
            };

            edits.push(edit);
        }

        Ok(edits)
    }

    /// Apply edits to content (in reverse order to maintain offsets)
    fn apply_edits(original: &str, mut edits: Vec<Edit>) -> Result<String, PatchError> {
        let mut result = original.to_string();

        // Sort by offset descending so we can apply without adjusting offsets
        edits.sort_by(|a, b| b.offset.cmp(&a.offset));

        for edit in &edits {
            if edit.offset + edit.length > result.len() {
                return Err(PatchError::EditOutOfBounds);
            }
            result.replace_range(edit.offset..edit.offset + edit.length, &edit.replacement);
        }

        Ok(result)
    }
}

/// Apply reindentation to text
fn apply_reindent(text: &str, reindent: &Reindent) -> Result<String, PatchError> {
    let lines: Vec<&str> = text.split('\n').collect();
    let mut result = Vec::with_capacity(lines.len());

    for line in lines {
        if line.is_empty() {
            result.push(String::new());
            continue;
        }

        // Strip prefix
        let stripped = if let Some(prefix) = &reindent.strip {
            line.strip_prefix(prefix.as_str()).ok_or_else(|| {
                PatchError::ReindentPrefixMismatch {
                    prefix: prefix.clone(),
                    line: line.to_string(),
                }
            })?
        } else {
            line
        };

        // Add prefix
        let final_line = if let Some(prefix) = &reindent.add {
            format!("{prefix}{stripped}")
        } else {
            stripped.to_string()
        };

        result.push(final_line);
    }

    Ok(result.join("\n"))
}

/// Generate a unified diff between old and new content
fn generate_diff(path: &str, old: &str, new: &str) -> String {
    let diff = TextDiff::from_lines(old, new);
    diff.unified_diff()
        .context_radius(3)
        .header(&format!("a/{path}"), &format!("b/{path}"))
        .to_string()
}

/// Check if content appears to be auto-generated
///
/// Checks the first ~2000 bytes of content for markers like "Code generated",
/// "DO NOT EDIT", etc. Uses safe UTF-8 truncation to avoid panics on
/// multi-byte characters.
pub(super) fn is_autogenerated(content: &str) -> bool {
    let markers = [
        "Code generated",
        "DO NOT EDIT",
        "generated by",
        "auto-generated",
        "@generated",
    ];

    // Find a valid UTF-8 char boundary for truncation
    let max_len = 2000;
    let end = if content.len() <= max_len {
        content.len()
    } else {
        // Walk backward from max_len to find a char boundary
        let mut end = max_len;
        while end > 0 && !content.is_char_boundary(end) {
            end -= 1;
        }
        end
    };
    let header = &content[..end];
    let header_lower = header.to_lowercase();

    markers
        .iter()
        .any(|m| header_lower.contains(&m.to_lowercase()))
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::path::PathBuf;

    fn path(s: &str) -> PathBuf {
        PathBuf::from(s)
    }

    #[test]
    fn test_overwrite_new_file() {
        let mut planner = PatchPlanner::new();
        let plan = planner
            .plan(
                &path("test.txt"),
                None,
                &[PatchRequest {
                    operation: Operation::Overwrite,
                    old_text: None,
                    new_text: Some("hello world".to_string()),
                    to_clipboard: None,
                    from_clipboard: None,
                    reindent: None,
                }],
            )
            .unwrap();

        assert_eq!(plan.resulting_content, "hello world");
        assert_eq!(plan.effects.len(), 1);
        match &plan.effects[0] {
            PatchEffect::WriteFile { path, content } => {
                assert_eq!(path, &PathBuf::from("test.txt"));
                assert_eq!(content, "hello world");
            }
        }
    }

    #[test]
    fn test_replace_existing_content() {
        let mut planner = PatchPlanner::new();
        let plan = planner
            .plan(
                &path("test.txt"),
                Some("hello world"),
                &[PatchRequest {
                    operation: Operation::Replace,
                    old_text: Some("world".to_string()),
                    new_text: Some("rust".to_string()),
                    to_clipboard: None,
                    from_clipboard: None,
                    reindent: None,
                }],
            )
            .unwrap();

        assert_eq!(plan.resulting_content, "hello rust");
    }

    #[test]
    fn test_replace_on_nonexistent_fails() {
        let mut planner = PatchPlanner::new();
        let err = planner
            .plan(
                &path("test.txt"),
                None,
                &[PatchRequest {
                    operation: Operation::Replace,
                    old_text: Some("foo".to_string()),
                    new_text: Some("bar".to_string()),
                    to_clipboard: None,
                    from_clipboard: None,
                    reindent: None,
                }],
            )
            .unwrap_err();

        assert_eq!(err, PatchError::ReplaceOnNonexistent);
    }

    #[test]
    fn test_clipboard_operations() {
        let mut planner = PatchPlanner::new();

        // Cut "world" to clipboard
        let plan1 = planner
            .plan(
                &path("test.txt"),
                Some("hello world"),
                &[PatchRequest {
                    operation: Operation::Replace,
                    old_text: Some("world".to_string()),
                    new_text: Some(String::new()),
                    to_clipboard: Some("clip1".to_string()),
                    from_clipboard: None,
                    reindent: None,
                }],
            )
            .unwrap();

        assert_eq!(plan1.resulting_content, "hello ");
        assert_eq!(
            planner.clipboards().get("clip1"),
            Some(&"world".to_string())
        );

        // Paste from clipboard
        let plan2 = planner
            .plan(
                &path("test.txt"),
                Some("hello "),
                &[PatchRequest {
                    operation: Operation::AppendEof,
                    old_text: None,
                    new_text: None,
                    to_clipboard: None,
                    from_clipboard: Some("clip1".to_string()),
                    reindent: None,
                }],
            )
            .unwrap();

        assert_eq!(plan2.resulting_content, "hello world");
    }

    #[test]
    fn test_append_eof() {
        let mut planner = PatchPlanner::new();
        let plan = planner
            .plan(
                &path("test.txt"),
                Some("hello"),
                &[PatchRequest {
                    operation: Operation::AppendEof,
                    old_text: None,
                    new_text: Some(" world".to_string()),
                    to_clipboard: None,
                    from_clipboard: None,
                    reindent: None,
                }],
            )
            .unwrap();

        assert_eq!(plan.resulting_content, "hello world");
    }

    #[test]
    fn test_prepend_bof() {
        let mut planner = PatchPlanner::new();
        let plan = planner
            .plan(
                &path("test.txt"),
                Some("world"),
                &[PatchRequest {
                    operation: Operation::PrependBof,
                    old_text: None,
                    new_text: Some("hello ".to_string()),
                    to_clipboard: None,
                    from_clipboard: None,
                    reindent: None,
                }],
            )
            .unwrap();

        assert_eq!(plan.resulting_content, "hello world");
    }

    #[test]
    fn test_reindent() {
        let mut planner = PatchPlanner::new();
        let plan = planner
            .plan(
                &path("test.txt"),
                Some("MARKER"),
                &[PatchRequest {
                    operation: Operation::Replace,
                    old_text: Some("MARKER".to_string()),
                    new_text: Some("  line1\n  line2".to_string()),
                    to_clipboard: None,
                    from_clipboard: None,
                    reindent: Some(Reindent {
                        strip: Some("  ".to_string()),
                        add: Some("    ".to_string()),
                    }),
                }],
            )
            .unwrap();

        assert_eq!(plan.resulting_content, "    line1\n    line2");
    }

    #[test]
    fn test_multiple_patches() {
        let mut planner = PatchPlanner::new();
        let plan = planner
            .plan(
                &path("test.txt"),
                Some("AAA BBB CCC"),
                &[
                    PatchRequest {
                        operation: Operation::Replace,
                        old_text: Some("AAA".to_string()),
                        new_text: Some("111".to_string()),
                        to_clipboard: None,
                        from_clipboard: None,
                        reindent: None,
                    },
                    PatchRequest {
                        operation: Operation::Replace,
                        old_text: Some("CCC".to_string()),
                        new_text: Some("333".to_string()),
                        to_clipboard: None,
                        from_clipboard: None,
                        reindent: None,
                    },
                ],
            )
            .unwrap();

        assert_eq!(plan.resulting_content, "111 BBB 333");
    }

    #[test]
    fn test_empty_clipboard_name_treated_as_none() {
        // LLMs sometimes pass "" instead of omitting fromClipboard
        let mut planner = PatchPlanner::new();
        let plan = planner
            .plan(
                &path("test.txt"),
                Some("hello"),
                &[PatchRequest {
                    operation: Operation::Replace,
                    old_text: Some("hello".to_string()),
                    new_text: Some("world".to_string()),
                    to_clipboard: Some("".to_string()), // empty string
                    from_clipboard: Some("".to_string()), // empty string
                    reindent: None,
                }],
            )
            .unwrap(); // Should not error on empty clipboard names

        assert_eq!(plan.resulting_content, "world");
        // Empty string clipboard should not be stored
        assert!(!planner.clipboards().contains_key(""));
    }
}
