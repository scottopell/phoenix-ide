//! Pure patch planning logic
//!
//! The PatchPlanner contains all the core logic for patch operations,
//! operating on string content without any IO. This makes it ideal
//! for property-based testing.

use super::matching::{find_unique_match, reindent_text};
use super::types::*;
use similar::{ChangeTag, TextDiff};
use std::collections::HashMap;
use std::path::PathBuf;

/// Pure patch planner - no IO operations
///
/// Maintains clipboard state across calls and produces effects
/// that describe what IO operations should be performed.
#[derive(Debug, Clone, Default)]
pub struct PatchPlanner {
    clipboards: HashMap<String, String>,
}

impl PatchPlanner {
    pub fn new() -> Self {
        Self::default()
    }

    /// Create a planner with pre-populated clipboards (useful for testing)
    pub fn with_clipboards(clipboards: HashMap<String, String>) -> Self {
        Self { clipboards }
    }

    /// Get current clipboard contents (for testing)
    pub fn clipboards(&self) -> &HashMap<String, String> {
        &self.clipboards
    }

    /// Plan patches for a file
    ///
    /// # Arguments
    /// * `path` - The file path (used for effects and diff display)
    /// * `current_content` - Current file content, or None if file doesn't exist
    /// * `patches` - The patches to apply
    ///
    /// # Returns
    /// A PatchPlan containing effects to execute and metadata
    pub fn plan(
        &mut self,
        path: PathBuf,
        current_content: Option<&str>,
        patches: &[PatchRequest],
    ) -> Result<PatchPlan, PatchError> {
        if patches.is_empty() {
            return Err(PatchError::NoPatches);
        }

        // Validate operations on non-existent files
        let original = match current_content {
            Some(content) => content.to_string(),
            None => {
                for patch in patches {
                    if matches!(patch.operation, Operation::Replace) {
                        return Err(PatchError::ReplaceOnNonexistent);
                    }
                }
                String::new()
            }
        };

        // Build edit list
        let edits = self.build_edits(&original, patches)?;

        // Apply edits to get result
        let resulting_content = self.apply_edits(&original, edits)?;

        // Generate diff
        let diff = generate_diff(&path.display().to_string(), &original, &resulting_content);

        // Check for autogenerated markers
        let autogenerated_warning = is_autogenerated(&resulting_content);

        // Build effects
        let effects = vec![PatchEffect::WriteFile {
            path: path.clone(),
            content: resulting_content.clone(),
        }];

        Ok(PatchPlan {
            effects,
            resulting_content,
            diff,
            autogenerated_warning,
        })
    }

    /// Build a list of edits from patch requests
    fn build_edits(
        &mut self,
        original: &str,
        patches: &[PatchRequest],
    ) -> Result<Vec<Edit>, PatchError> {
        let mut edits = Vec::new();

        for patch in patches {
            // Get new text (from clipboard if specified)
            let mut new_text = match &patch.from_clipboard {
                Some(name) => self
                    .clipboards
                    .get(name)
                    .ok_or_else(|| PatchError::ClipboardNotFound(name.clone()))?
                    .clone(),
                None => patch.new_text.clone().unwrap_or_default(),
            };

            // Apply reindentation
            if let Some(reindent) = &patch.reindent {
                new_text = apply_reindent(&new_text, reindent)?;
            }

            // Store to clipboard if requested
            if let Some(name) = &patch.to_clipboard {
                if let Some(old_text) = &patch.old_text {
                    self.clipboards.insert(name.clone(), old_text.clone());
                }
            }

            // Determine edit based on operation
            let edit = match patch.operation {
                Operation::PrependBof => Edit {
                    offset: 0,
                    length: 0,
                    replacement: new_text,
                },
                Operation::AppendEof => Edit {
                    offset: original.len(),
                    length: 0,
                    replacement: new_text,
                },
                Operation::Overwrite => Edit {
                    offset: 0,
                    length: original.len(),
                    replacement: new_text,
                },
                Operation::Replace => {
                    let old_text = patch
                        .old_text
                        .as_ref()
                        .ok_or(PatchError::MissingOldText)?;

                    let spec = find_unique_match(original, old_text)?;

                    // Update clipboard with actual matched text if it differed
                    if let Some(name) = &patch.to_clipboard {
                        let matched = &original[spec.offset..spec.offset + spec.length];
                        self.clipboards.insert(name.clone(), matched.to_string());
                    }

                    Edit {
                        offset: spec.offset,
                        length: spec.length,
                        replacement: new_text,
                    }
                }
            };

            edits.push(edit);
        }

        Ok(edits)
    }

    /// Apply edits to content (in reverse order to maintain offsets)
    fn apply_edits(&self, original: &str, mut edits: Vec<Edit>) -> Result<String, PatchError> {
        let mut result = original.to_string();
        
        // Sort by offset descending so we can apply without adjusting offsets
        edits.sort_by(|a, b| b.offset.cmp(&a.offset));

        for edit in &edits {
            if edit.offset + edit.length > result.len() {
                return Err(PatchError::EditOutOfBounds);
            }
            result.replace_range(edit.offset..edit.offset + edit.length, &edit.replacement);
        }

        Ok(result)
    }
}

/// Apply reindentation to text
fn apply_reindent(text: &str, reindent: &Reindent) -> Result<String, PatchError> {
    let lines: Vec<&str> = text.split('\n').collect();
    let mut result = Vec::with_capacity(lines.len());

    for line in lines {
        if line.is_empty() {
            result.push(String::new());
            continue;
        }

        // Strip prefix
        let stripped = if let Some(prefix) = &reindent.strip {
            line.strip_prefix(prefix.as_str()).ok_or_else(|| {
                PatchError::ReindentPrefixMismatch {
                    prefix: prefix.clone(),
                    line: line.to_string(),
                }
            })?
        } else {
            line
        };

        // Add prefix
        let final_line = if let Some(prefix) = &reindent.add {
            format!("{}{}", prefix, stripped)
        } else {
            stripped.to_string()
        };

        result.push(final_line);
    }

    Ok(result.join("\n"))
}

/// Generate a unified diff between old and new content
fn generate_diff(path: &str, old: &str, new: &str) -> String {
    let diff = TextDiff::from_lines(old, new);
    let mut output = String::new();

    output.push_str(&format!("--- a/{}\n", path));
    output.push_str(&format!("--- b/{}\n", path));

    for (idx, group) in diff.grouped_ops(3).iter().enumerate() {
        if idx > 0 {
            output.push('\n');
        }
        for op in group {
            for change in diff.iter_changes(op) {
                let tag = match change.tag() {
                    ChangeTag::Delete => "-",
                    ChangeTag::Insert => "+",
                    ChangeTag::Equal => " ",
                };
                output.push_str(&format!("{}{}", tag, change));
            }
        }
    }

    output
}

/// Check if content appears to be auto-generated
fn is_autogenerated(content: &str) -> bool {
    let markers = [
        "Code generated",
        "DO NOT EDIT",
        "generated by",
        "auto-generated",
        "@generated",
    ];

    let header = &content[..content.len().min(2000)];
    let header_lower = header.to_lowercase();

    markers
        .iter()
        .any(|m| header_lower.contains(&m.to_lowercase()))
}

#[cfg(test)]
mod tests {
    use super::*;

    fn path(s: &str) -> PathBuf {
        PathBuf::from(s)
    }

    #[test]
    fn test_overwrite_new_file() {
        let mut planner = PatchPlanner::new();
        let plan = planner
            .plan(
                path("test.txt"),
                None,
                &[PatchRequest {
                    operation: Operation::Overwrite,
                    old_text: None,
                    new_text: Some("hello world".to_string()),
                    to_clipboard: None,
                    from_clipboard: None,
                    reindent: None,
                }],
            )
            .unwrap();

        assert_eq!(plan.resulting_content, "hello world");
        assert_eq!(plan.effects.len(), 1);
        match &plan.effects[0] {
            PatchEffect::WriteFile { path, content } => {
                assert_eq!(path, &PathBuf::from("test.txt"));
                assert_eq!(content, "hello world");
            }
        }
    }

    #[test]
    fn test_replace_existing_content() {
        let mut planner = PatchPlanner::new();
        let plan = planner
            .plan(
                path("test.txt"),
                Some("hello world"),
                &[PatchRequest {
                    operation: Operation::Replace,
                    old_text: Some("world".to_string()),
                    new_text: Some("rust".to_string()),
                    to_clipboard: None,
                    from_clipboard: None,
                    reindent: None,
                }],
            )
            .unwrap();

        assert_eq!(plan.resulting_content, "hello rust");
    }

    #[test]
    fn test_replace_on_nonexistent_fails() {
        let mut planner = PatchPlanner::new();
        let err = planner
            .plan(
                path("test.txt"),
                None,
                &[PatchRequest {
                    operation: Operation::Replace,
                    old_text: Some("foo".to_string()),
                    new_text: Some("bar".to_string()),
                    to_clipboard: None,
                    from_clipboard: None,
                    reindent: None,
                }],
            )
            .unwrap_err();

        assert_eq!(err, PatchError::ReplaceOnNonexistent);
    }

    #[test]
    fn test_clipboard_operations() {
        let mut planner = PatchPlanner::new();

        // Cut "world" to clipboard
        let plan1 = planner
            .plan(
                path("test.txt"),
                Some("hello world"),
                &[PatchRequest {
                    operation: Operation::Replace,
                    old_text: Some("world".to_string()),
                    new_text: Some("".to_string()),
                    to_clipboard: Some("clip1".to_string()),
                    from_clipboard: None,
                    reindent: None,
                }],
            )
            .unwrap();

        assert_eq!(plan1.resulting_content, "hello ");
        assert_eq!(planner.clipboards().get("clip1"), Some(&"world".to_string()));

        // Paste from clipboard
        let plan2 = planner
            .plan(
                path("test.txt"),
                Some("hello "),
                &[PatchRequest {
                    operation: Operation::AppendEof,
                    old_text: None,
                    new_text: None,
                    to_clipboard: None,
                    from_clipboard: Some("clip1".to_string()),
                    reindent: None,
                }],
            )
            .unwrap();

        assert_eq!(plan2.resulting_content, "hello world");
    }

    #[test]
    fn test_append_eof() {
        let mut planner = PatchPlanner::new();
        let plan = planner
            .plan(
                path("test.txt"),
                Some("hello"),
                &[PatchRequest {
                    operation: Operation::AppendEof,
                    old_text: None,
                    new_text: Some(" world".to_string()),
                    to_clipboard: None,
                    from_clipboard: None,
                    reindent: None,
                }],
            )
            .unwrap();

        assert_eq!(plan.resulting_content, "hello world");
    }

    #[test]
    fn test_prepend_bof() {
        let mut planner = PatchPlanner::new();
        let plan = planner
            .plan(
                path("test.txt"),
                Some("world"),
                &[PatchRequest {
                    operation: Operation::PrependBof,
                    old_text: None,
                    new_text: Some("hello ".to_string()),
                    to_clipboard: None,
                    from_clipboard: None,
                    reindent: None,
                }],
            )
            .unwrap();

        assert_eq!(plan.resulting_content, "hello world");
    }

    #[test]
    fn test_reindent() {
        let mut planner = PatchPlanner::new();
        let plan = planner
            .plan(
                path("test.txt"),
                Some("MARKER"),
                &[PatchRequest {
                    operation: Operation::Replace,
                    old_text: Some("MARKER".to_string()),
                    new_text: Some("  line1\n  line2".to_string()),
                    to_clipboard: None,
                    from_clipboard: None,
                    reindent: Some(Reindent {
                        strip: Some("  ".to_string()),
                        add: Some("    ".to_string()),
                    }),
                }],
            )
            .unwrap();

        assert_eq!(plan.resulting_content, "    line1\n    line2");
    }

    #[test]
    fn test_multiple_patches() {
        let mut planner = PatchPlanner::new();
        let plan = planner
            .plan(
                path("test.txt"),
                Some("AAA BBB CCC"),
                &[
                    PatchRequest {
                        operation: Operation::Replace,
                        old_text: Some("AAA".to_string()),
                        new_text: Some("111".to_string()),
                        to_clipboard: None,
                        from_clipboard: None,
                        reindent: None,
                    },
                    PatchRequest {
                        operation: Operation::Replace,
                        old_text: Some("CCC".to_string()),
                        new_text: Some("333".to_string()),
                        to_clipboard: None,
                        from_clipboard: None,
                        reindent: None,
                    },
                ],
            )
            .unwrap();

        assert_eq!(plan.resulting_content, "111 BBB 333");
    }
}
